## lab4:进程管理

#### 练习1：分配并初始化一个进程控制块（需要编码）

alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。

> 【提示】在alloc_proc函数的实现中，需要初始化的proc_struct结构中的成员变量至少包括：state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name。

```
    // 初始化进程的状态为初始状态
    proc->state = PROC_UNINIT;
    // 初始化进程的PID为-1
    proc->pid = -1;
    // 初始化运行次数为0
    proc->runs = 0;
    // 初始化进程的内核栈地址
    proc->kstack = 0; 
    // 初始化need_resched标志为0
    proc->need_resched = 0;
    // 初始化父进程为NULL
    proc->parent = NULL;
    // 初始化进程的内存管理结构为NULL,之后分配和关联一个mm_struct结构
    proc->mm = NULL;
    // 初始化进程的上下文
    memset(&(proc->context), 0, sizeof(struct context));
    // 初始化trapframe为NULL，需要在之后分配和关联一个trapframe结构
    proc->tf = NULL;
    // 初始化CR3寄存器的值
    proc->cr3 = boot_cr3; 
    // 初始化进程的标志
    proc->flags = 0; 
    // 初始化进程的名称
    memset(proc->name, 0, PROC_NAME_LEN + 1); 
```

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请说明proc_struct中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

`struct context context`：包含了用于保存进程的上下文信息的数据结构。上下文信息包括通用寄存器、栈指针、指令指针等，这些信息用于在进程之间的切换时保存和恢复进程的执行状态，以确保进程能够正确继续执行。。

`struct trapframe *tf`：用于保存进程在发生中断或异常时的寄存器状态。当进程在用户态执行系统调用或遇到中断时，当前寄存器状态会被保存在 `struct trapframe` 中，以便在中断处理完成后能够恢复到之前的状态。

#### 练习2：为新创建的内核线程分配资源（需要编码）

创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用**do_fork**函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们**实际需要"fork"的东西就是stack和trapframe**。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：

- 调用alloc_proc，首先获得一块用户信息块。
- 为进程分配一个内核栈。
- 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
- 复制原进程上下文到新进程
- 将新进程添加到进程列表
- 唤醒新进程
- 返回新进程号

```
    proc = alloc_proc();//调用alloc_proc，首先获得一块用户信息块。
     if (proc == NULL) {
        goto fork_out;//如果分配失败，跳到 fork_out 标签处，返回错误 -E_NO_MEM。
    }
    proc->parent=current;//如果进程分配成功，它将将当前进程标记为新进程的父进程
    //为进程分配一个内核栈。
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }
    // 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }
    // 复制原进程上下文到新进程
    copy_thread(proc, stack, tf);
    //将新进程添加到进程列表
    bool intr_flag;
    local_intr_save(intr_flag);// 禁用中断
    {
        proc->pid = get_pid();//为新进程分配一个唯一的进程标识符（PID）
        hash_proc(proc);//将新进程添加到进程管理的数据结构中
        list_add(&proc_list, &(proc->list_link));//将新进程加入进程列表
        nr_process ++;//增加进程计数。
    }
    local_intr_restore(intr_flag);//恢复之前保存的中断状态，恢复中断
    //唤醒新进程
    wakeup_proc(proc);
    ret = proc->pid;//返回新进程号
```

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

ucore会给每个新fork的线程一个唯一的id。分析与理由：

1. static int get_pid(void)函数：维护了两个关键的变量，`next_safe`和`last_pid`，它们用于跟踪下一个可用的PID和上一个已分配的PID。

2. 每当要为一个新线程分配PID时，它会递增`last_pid`，然后检查是否与现有进程的PID冲突。如果冲突，它会自动递增`last_pid`以查找下一个可用的PID。

3. 当`last_pid`大于或等于`next_safe`时，它会重新开始搜索下一个可用的PID，确保不会与现有进程的PID冲突。

4. 如果无法找到可用的PID，它会重新开始，从1开始分配PID。

#### 练习3：编写proc_run 函数（需要编码）

proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：

- 检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
- 禁用中断。你可以使用`/kern/sync/sync.h`中定义好的宏`local_intr_save(x)`和`local_intr_restore(x)`来实现关、开中断。
- 切换当前进程为要运行的进程。
- 切换页表，以便使用新进程的地址空间。`/libs/riscv.h`中提供了`lcr3(unsigned int cr3)`函数，可实现修改CR3寄存器值的功能。
- 实现上下文切换。`/kern/process`中已经预先编写好了`switch.S`，其中定义了`switch_to()`函数。可实现两个进程的context切换。
- 允许中断。

```
        bool intr_flag;
        local_intr_save(intr_flag);  // 禁用中断
        {
            struct proc_struct *prev = current, *next = proc; // 定义前一个进程和后一个进程
            current = proc;//切换当前进程为要运行的进程。
            lcr3(next->cr3); //切换页表，以便使用新进程的地址空间。
            switch_to(&(prev->context), &(next->context)); //实现上下文切换
        }

        local_intr_restore(intr_flag);  // 启用中断
```

请回答如下问题：

- 在本实验的执行过程中，创建且运行了几个内核线程？

2个。创建第 0 个内核线程 idleproc；创建第 1 个内核线程 initproc；调度并执行内核线程 initproc。

#### 扩展练习 Challenge：

- 说明语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`是如何实现开关中断的？
1. `__intr_save` 函数：
   
   - 该函数首先通过 `read_csr(sstatus)` 读取当前CPU核的状态寄存器（`sstatus` 寄存器）的值，这个寄存器包含了关于中断的信息。
   - 然后使用 `&` 运算符与 `SSTATUS_SIE` 进行按位与运算。`SSTATUS_SIE` 是一个宏定义，表示中断使能（interrupt enable）的位掩码。如果这个位为1，表示中断是被允许的。
   - 如果 `SSTATUS_SIE` 位为0，说明中断是允许的，函数就会调用 `intr_disable()` 来禁用中断，并返回0，表示中断已被保存。
   - 如果 `SSTATUS_SIE` 位为1，说明中断已经被禁用，函数不执行任何操作，并返回1，表示中断未被保存。

2. `__intr_restore` 函数：
   
   - 这个函数根据传入的 `flag` 参数，来决定是否要重新启用中断。
   - 如果 `flag` 为1，说明在调用 `__intr_save` 时中断是被保存的，这个函数调用 `intr_enable()` 来重新启用中断。
   - 如果 `flag` 为0，说明在调用 `__intr_save` 时中断是未被保存的，这个函数不执行任何操作，中断状态保持不变。

3. `local_intr_save` 宏：
   
   - 这个宏是一个方便的封装，实际上是在 `__intr_save` 函数前后分别执行了 `intr_disable()` 和 `intr_enable()`，并通过 `x` 参数返回中断状态的保存情况。如果 `__intr_save` 返回1，表示中断已被保存，`x` 会被设置为1；如果返回0，`x` 会被设置为0。

4. `local_intr_restore` 宏：
   
   - 这个宏实际上是直接调用 `__intr_restore` 函数，并将传入的 `x` 参数传递给它，以根据 `x` 的值来决定是否重新启用中断。

总的来说，这些代码通过读取和修改 `sstatus` 寄存器中的位信息来实现中断的保存和恢复。

#### 总结

- 本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）

当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（这里用线程或进程表示）“感到”它们各自拥有“自己”的CPU。

内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：

- 内核线程只运行在内核态
- 用户进程会在在用户态和内核态交替运行
- 所有内核线程共用ucore内核内存空间，不需为每个内核线程维护单独的内存空间
- 而用户进程需要维护各自的用户内存空间

程序：编写的源代码，经过编译器编译就变成了可执行文件，称为程序。程序只是一个不动的文件。

进程：当一个程序被用户或操作系统启动，分配资源，装载进内存开始执行后，它就成为了一个**进程**。进程包含程序的内容，也就是它的静态的代码部分，也包括一些在运行时在可以体现出来的信息，比如堆栈，寄存器等数据，这些组成了进程“正在运行”的特性。

线程：一个进程可以对应一个线程，也可以对应很多线程。这些线程之间往往具有相同的代码，共享一块内存，但是却有不同的CPU执行状态。进程更多的作为一个资源管理的实体（因为操作系统分配网络等资源时往往是基于进程的），这样线程就作为可以被调度的最小单元，给了调度器更多的调度可能。

管理线程的数据结构：进程控制块

*kern/process/proc.h*中定义struct proc_struct进程管理信息

为了管理系统中所有的进程控制块，uCore维护了一些全局变量（kern/process/proc.c）：

进程上下文使用结构体`struct context`保存，其中包含了`ra`，`sp`，`s0~s11`共14个寄存器。

实验执行流程：

在前面实验的基础上，进行CPU的虚拟化，即让ucore实现分时共享CPU，实现多条控制流能够并发执行。把控制流看作是一个内核线程。本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，如果要让内核线程运行，我们首先要创建内核线程对应的进程控制块，还需把这些进程控制块通过链表连在一起，便于随时进行插入，删除和查找操作等进程管理事务。这个链表就是进程控制块链表。然后在通过调度器（scheduler）来让不同的内核线程在不同的时间段占用CPU执行，实现对CPU的分时共享。

`kern/init/init.c`中的kern_init函数完成虚拟内存的初始化工作后，就调用了proc_init函数。

`kern/process/proc.c`中的`proc_init`：进程初始化，启动了创建内核线程。完成了idleproc内核线程和initproc内核线程的创建或复制工作。idleproc内核线程的工作就是不停地查询，看是否有其他内核线程可以执行了，如果有，马上让调度器选择那个内核线程执行。所以idleproc内核线程是在ucore操作系统没有其他内核线程可执行的情况下才会被调用。调用kernel_thread函数来创建initproc内核线程。initproc内核线程的工作就是显示“Hello World”，表明自己存在且能正常工作了。

创建并执行内核线程：建立进程控制块（proc.c中的alloc_proc函数），通过进程控制块来创建具体的进程/线程。

在lab4中，涉及了一些操作系统中非常重要的原理，包括但不限于以下内容：

1. 中断处理机制：实验1主要讲解了中断处理机制，包括对中断的响应、中断处理函数的调用等内容。

2. 上下文切换：lab4涉及了内核线程的切换和基本调度过程，这涉及到上下文的保存与恢复，是操作系统中非常重要的内容之一。

3. 进程管理：lab4涉及了内核线程的创建和执行管理过程，这是操作系统中进程管理的核心内容之一。

4. 调度算法：lab4中涉及了基本的调度过程，包括如何让多个内核线程共享一个CPU，这涉及到调度算法的设计和实现。

虽然lab4并未涉及所有操作系统原理，但是涉及了一些非常重要的内容，对于理解操作系统的基本原理和实现具有重要意义。

- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

在lab4中，主要涉及了进程管理的内容，包括内核线程的创建、执行、切换和调度过程。虽然lab4涉及了一些重要的操作系统原理，但是有一些重要的原理在这个实验中并未体现，包括但不限于以下内容：

1. 内存管理：lab4并未涉及虚拟内存的管理和页表的建立和使用方法，这是操作系统中非常重要的内容，但在lab4中并未体现。

2. 文件系统：lab4也没有涉及文件系统的管理和操作，包括文件的创建、读写、删除等操作，这也是操作系统中的重要内容之一。

3. 中断处理：lab4中并未涉及操作系统如何处理中断的机制，包括中断的产生、处理和响应等内容。

这些内容在操作系统中都是非常重要的，但在lab4中并未直接体现。
